{"ast":null,"code":"export const getBabysitters = props => {\n  return {\n    type: 'FETCH_BABYSITTERS',\n    payload: props\n  };\n};\nexport const slotMerge = babyData => {\n  // return console.log(\"babyData test\", babyData[0].slots)\n  const allData = babyData.map(babysitters => babysitters.slots);\n  const slots = allData.map(slot => slot); // console.log(\"slots is\", slots)\n  // const slotEach = slots.map(slot => console.log(\"slotEach is\", slot))\n\n  const allSlots = [];\n\n  for (let i of slots) {\n    console.log(\"i is\", i[0]);\n    const index = allSlots.findIndex(s => s.day_of_week === i.day_of_week);\n\n    if (index !== -1) {\n      allSlots[index].time_of_day.push(i.time_of_day);\n    } else {\n      allSlots.push({ ...slot,\n        time\n      });\n    }\n  }\n};\n{\n  /*\r\n    const slots = data.slots\r\n    const consolidatedSlots = []\r\n    for(slot of slots){\r\n        const index = consolidatedSlots.findIndex(s => s.day === slot.day)\r\n        if(index !== -1){ // if the index is not -1 it means it exists\r\n            \r\n            // add the new timeslot to the slot for the day that already is in your consolidatedSlots\r\n            consolidatedSlots[index].times.push(slot.time)\r\n        }else{ // if index IS -1, you couldnt find a slot with this day\r\n            \r\n            // turn time into times and make it an array of the time option\r\n            consolidatedSlots.push({...slot, times: [slot.time]}) \r\n        }\r\n    }\r\n    ​\r\n    // now your action.payload (or whatever key you are using) is going to be consolidatedSlots\r\n    */\n}\nexport function fetchBabysitters() {\n  return async dispatch => {\n    dispatch({\n      type: 'LOADING_BABYSITTERS'\n    });\n\n    try {\n      const res = await fetch('http://localhost:3000/api/v1/babysitters');\n\n      if (!res.ok) {\n        throw res;\n      }\n\n      const babyData = await res.json();\n      slotMerge(babyData);\n      dispatch(getBabysitters(babyData));\n    } catch (err) {\n      alert(\"Failed to load babysitters\");\n    }\n  };\n}","map":{"version":3,"sources":["/mnt/c/Users/aviga/Desktop/Flatiron/Projects/react_babysitting/babysitting-app/src/actions/fetchBabysitters.js"],"names":["getBabysitters","props","type","payload","slotMerge","babyData","allData","map","babysitters","slots","slot","allSlots","i","console","log","index","findIndex","s","day_of_week","time_of_day","push","time","fetchBabysitters","dispatch","res","fetch","ok","json","err","alert"],"mappings":"AAAA,OAAO,MAAMA,cAAc,GAAIC,KAAD,IAAW;AACrC,SAAO;AAAEC,IAAAA,IAAI,EAAE,mBAAR;AAA6BC,IAAAA,OAAO,EAAEF;AAAtC,GAAP;AACH,CAFM;AAIP,OAAO,MAAMG,SAAS,GAAGC,QAAQ,IAAI;AACjC;AACA,QAAMC,OAAO,GAAGD,QAAQ,CAACE,GAAT,CAAaC,WAAW,IAAIA,WAAW,CAACC,KAAxC,CAAhB;AACA,QAAMA,KAAK,GAAGH,OAAO,CAACC,GAAR,CAAYG,IAAI,IAAIA,IAApB,CAAd,CAHiC,CAIjC;AACA;;AACA,QAAMC,QAAQ,GAAG,EAAjB;;AACA,OAAK,IAAIC,CAAT,IAAcH,KAAd,EAAqB;AACjBI,IAAAA,OAAO,CAACC,GAAR,CAAY,MAAZ,EAAoBF,CAAC,CAAC,CAAD,CAArB;AACA,UAAMG,KAAK,GAAGJ,QAAQ,CAACK,SAAT,CAAmBC,CAAC,IAAIA,CAAC,CAACC,WAAF,KAAkBN,CAAC,CAACM,WAA5C,CAAd;;AACA,QAAIH,KAAK,KAAK,CAAC,CAAf,EAAkB;AACdJ,MAAAA,QAAQ,CAACI,KAAD,CAAR,CAAgBI,WAAhB,CAA4BC,IAA5B,CAAiCR,CAAC,CAACO,WAAnC;AACH,KAFD,MAEO;AACHR,MAAAA,QAAQ,CAACS,IAAT,CAAc,EAAC,GAAGV,IAAJ;AAAUW,QAAAA;AAAV,OAAd;AACH;AACJ;AACJ,CAhBM;AAkBP;AAAE;;;;;;;;;;;;;;;;;;AAiBK;AAEP,OAAO,SAASC,gBAAT,GAA4B;AAC/B,SAAO,MAAOC,QAAP,IAAoB;AACvBA,IAAAA,QAAQ,CAAC;AAAErB,MAAAA,IAAI,EAAE;AAAR,KAAD,CAAR;;AACA,QAAI;AACA,YAAMsB,GAAG,GAAG,MAAMC,KAAK,CAAC,0CAAD,CAAvB;;AACA,UAAI,CAACD,GAAG,CAACE,EAAT,EAAa;AACT,cAAMF,GAAN;AACH;;AACD,YAAMnB,QAAQ,GAAG,MAAMmB,GAAG,CAACG,IAAJ,EAAvB;AAEAvB,MAAAA,SAAS,CAACC,QAAD,CAAT;AAEAkB,MAAAA,QAAQ,CAACvB,cAAc,CAACK,QAAD,CAAf,CAAR;AACH,KAVD,CAUE,OAAOuB,GAAP,EAAY;AACVC,MAAAA,KAAK,CAAC,4BAAD,CAAL;AACH;AACJ,GAfD;AAiBH","sourcesContent":["export const getBabysitters = (props) => {\r\n    return { type: 'FETCH_BABYSITTERS', payload: props }\r\n}\r\n\r\nexport const slotMerge = babyData => {\r\n    // return console.log(\"babyData test\", babyData[0].slots)\r\n    const allData = babyData.map(babysitters => babysitters.slots)\r\n    const slots = allData.map(slot => slot)\r\n    // console.log(\"slots is\", slots)\r\n    // const slotEach = slots.map(slot => console.log(\"slotEach is\", slot))\r\n    const allSlots = []\r\n    for (let i of slots) {\r\n        console.log(\"i is\", i[0])\r\n        const index = allSlots.findIndex(s => s.day_of_week === i.day_of_week)\r\n        if (index !== -1) {\r\n            allSlots[index].time_of_day.push(i.time_of_day)\r\n        } else {\r\n            allSlots.push({...slot, time})\r\n        }\r\n    }\r\n}\r\n\r\n{ /*\r\n    const slots = data.slots\r\n    const consolidatedSlots = []\r\n    for(slot of slots){\r\n        const index = consolidatedSlots.findIndex(s => s.day === slot.day)\r\n        if(index !== -1){ // if the index is not -1 it means it exists\r\n            \r\n            // add the new timeslot to the slot for the day that already is in your consolidatedSlots\r\n            consolidatedSlots[index].times.push(slot.time)\r\n        }else{ // if index IS -1, you couldnt find a slot with this day\r\n            \r\n            // turn time into times and make it an array of the time option\r\n            consolidatedSlots.push({...slot, times: [slot.time]}) \r\n        }\r\n    }\r\n    ​\r\n    // now your action.payload (or whatever key you are using) is going to be consolidatedSlots\r\n    */}\r\n\r\nexport function fetchBabysitters() {\r\n    return async (dispatch) => {\r\n        dispatch({ type: 'LOADING_BABYSITTERS' })\r\n        try {\r\n            const res = await fetch('http://localhost:3000/api/v1/babysitters')\r\n            if (!res.ok) {\r\n                throw res\r\n            }\r\n            const babyData = await res.json()\r\n\r\n            slotMerge(babyData)\r\n\r\n            dispatch(getBabysitters(babyData))\r\n        } catch (err) {\r\n            alert(\"Failed to load babysitters\")\r\n        }\r\n    }\r\n\r\n}\r\n\r\n\r\n\r\n"]},"metadata":{},"sourceType":"module"}